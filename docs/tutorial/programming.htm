<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>VASSAL Tutorial - Programming</title>
             
  <meta http-equiv="content-type"
 content="text/html; charset=ISO-8859-1">
</head>
  <body>
      
<h1 align="center"><a href="index.htm">VASSAL Tutorials</a></h1>
      
<div align="center"><small><b> <a href="module.htm">Board Game</a> |  <a
 href="cardGame.htm">Card Game</a> |  <a href="doubleBlind.htm">Double-Blind</a> 
|  <a href="programming.htm">Programming</a><br>
  </b></small> </div>
    <small><b> <br>
   </b></small>   
<hr width="100%" size="2">       
<div align="left">    <b><font size="+2">Programming Tutorial</font></b></div>
   
<center></center>
      
<p>VASSAL provides the capability for you to write and use your own Java classes
in a module. Your classes should extend and use the VASSAL engine library
classes. Documentation for the VASSAL classes is provided with the VASSAL
download. </p>
   
<p><b>Java VM</b> </p>
   
<p>VASSAL is built to be compatible with version 1.1 of the Java runtime,
 although Swing components may still be used. The main reason is that VASSAL
 purports to be a cross-platform engine, and Macintosh users who are not
running  OS X cannot run versions 1.2 or 1.3 of Java.&nbsp; Therefore, when
adding  your own code to a VASSAL module, please try to conform to the Java
1.1 API.  &nbsp;If you must use methods from later Java versions (to make
use of Java2D,  for example), please try to trap ClassNotFound and NoSuchMethod
errors so  that 1.1 users can still run the program without bombing. </p>
   
<p>When compiling your custom code, all of the <tt>.jar</tt> files in VASSAL's 
 <tt>lib</tt> directory should be in your classpath:&nbsp; <tt>VASSAL.jar, 
 swingall.jar, jaxp.jar, crimson.jar</tt> </p>
   
<p><b>The Module File</b> </p>
   
<p>A VASSAL module file is an ordinary zip archive. You can open it with any
standard zip program. Inside, you will find an "images" directory containing 
 all the graphics used by the module and a file named "buildFile" which is
 used by VASSAL to build the module.&nbsp; Any custom classes that you create
 to use in a module must be added to the zip archive.&nbsp; Simply add the
 <tt>.class</tt> files to the archive, with a directory structure mirroring
 the package structure in the usual way the <tt>.jar</tt> archives are made.&nbsp;
 Once the <tt>.class </tt>files exist in the archive, they can be imported
 from VASSAL's Configuration Window. </p>
   
<p><b>The <tt>AbstractConfigurable</tt> class</b> </p>
   
<p>In order to be imported into a VASSAL module, your classes must implement 
 the <tt>Configurable</tt> interface.&nbsp; The simplest way to do this is
 to inherit from the <tt>AbstractConfigurable</tt> class.&nbsp; Refer to
the  JavaDoc documentation for descriptions of the various abstract methods
that  your class must implement. </p>
   
<hr> <a name="components"> </a>  
<center><a name="components"><b><font size="+2">Designing custom VASSAL module
 components</font></b></a></center>
      
<p><a name="components"><b>An example custom component</b> </a></p>
   
<p><a name="components">In this section of the tutorial, we'll add our own
 customized class to the Zap Wars module that we created in the first part
 of the tutorial. Suppose Zap Wars requires tracking of a Tension index between
 the two races. Whenever the Flesh-Eating Zombies dismember a Fuzzy Creature,
 or a Fuzzy Creature does something annoyingly cute, the tension index rises
 by a random amount. We'll create a class that tracks the Tension index and
 provides a button to add a random increment to it. We'll also show how to
 communicate this action to other players and how to save the results when
 we save a game. </a></p>
   
<p><a name="components">Our class, </a><a
 href="ZapWarsData/src/zap/Tension.java"><tt>Tension.java</tt></a>, will extend
<tt>AbstractConfigurable</tt>. We will have two attributes: "min" for the
minimum of the random increment to the Tension index, and "max" for the maximum.
</p>
   
<pre>&nbsp;&nbsp;&nbsp; private int index = 0;<br>&nbsp;&nbsp;&nbsp; private int minChange = 0;<br>&nbsp;&nbsp;&nbsp; private int maxChange = 0;</pre>
   The <tt>getAttributeNames</tt>() and <tt>getAttributeValueString</tt>() 
methods are:   
<pre>&nbsp;&nbsp;&nbsp; public String[] getAttributeNames() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new String[]{MIN,MAX};<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public String getAttributeValueString(String key) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MIN.equals(key)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ""+minChange;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (MAX.equals(key)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ""+maxChange;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }</pre>
   We also must implement the <tt>getAttributeDescrptions</tt>() and <tt>getAttributeTypes</tt>() 
 methods:   
<pre>&nbsp;&nbsp;&nbsp; public String[] getAttributeDescriptions() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new String[]{"Minimum increment","Maximum increment"};<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public Class[] getAttributeTypes() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Class[]{Integer.class,Integer.class};<br>&nbsp;&nbsp;&nbsp; }</pre>
   The <tt>setAttribute</tt>() method must be able to accept either a String 
 (the one returned by <tt>getAttributeValueString</tt>()) <br>
  or an instance of the corresponding Class in <tt>getAttributeTypes</tt>() 
 (an Integer):   
<pre>&nbsp;&nbsp;&nbsp; public void setAttribute(String key, Object value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MIN.equals(key)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (value instanceof String) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minChange = Integer.parseInt((String)value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (value instanceof Integer) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minChange = ((Integer)value).intValue();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (MAX.equals(key)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (value instanceof String) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxChange = Integer.parseInt((String)value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (value instanceof Integer) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxChange = ((Integer)value).intValue();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }</pre>
   During the initialization of a module, every component's <tt>addTo() </tt>method 
 is invoked.&nbsp; The argument is the component that appears as its parent 
 in the Configuration Window.&nbsp; This method (rather than the constructor) 
 is where most of the initialization should occur.&nbsp; Our component will 
 use two buttons: one to add a random increment to the Tension index and one
to display the current index. These buttons are added to the toolbar of the
main controls window in the <tt>addTo</tt>() method:   
<pre>&nbsp;&nbsp;&nbsp; public void addTo(Buildable parent) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GameModule mod = (GameModule)parent;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JButton b = new JButton("Increment");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.setAlignmentY(0.0F);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.addActionListener(new ActionListener() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void actionPerformed(ActionEvent evt) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; incrementButtonPressed();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod.getToolBar().add(b);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b = new JButton("Show total");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.setAlignmentY(0.0F);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.addActionListener(new ActionListener() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void actionPerformed(ActionEvent evt) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; totalButtonPressed();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod.getToolBar().add(b);<br>&nbsp;&nbsp;&nbsp; }</pre>
   The <tt>removeFrom()</tt> method is invoked only when editing a module, 
if a user deletes it from the Configuration Window.&nbsp; Our <tt>removeFrom</tt>() 
 method simply undoes what was done in the <tt>addTo</tt>() method:   
<pre>&nbsp;&nbsp;&nbsp; public void removeFrom(Buildable parent) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GameModule mod = (GameModule)parent;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod.getToolBar().remove(addButton);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod.getToolBar().remove(showButton);<br>&nbsp;&nbsp;&nbsp; }</pre>
   Unless you expect other people to be editing your modules, it's also reasonable 
 to do nothing in the removeFrom() method.&nbsp; Likewise, providing a HelpFile 
 is usually not necessary.   
<pre>&nbsp;&nbsp; public VASSAL.build.module.documentation.HelpFile getHelpFile() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;<br>&nbsp;&nbsp;&nbsp; }</pre>
   Since this component will not contain any other components in the Configuration 
 Window, we return an empty list of sub-component types:   
<pre>&nbsp;&nbsp;&nbsp; public Class[] getAllowableConfigureComponents() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Class[0];<br>&nbsp;&nbsp;&nbsp; }</pre>
   The compiled class file must be added to the module zipfile. Open the
module  with your favorite Zip utility and add the .class files. Be sure
to preserve  the package structure, i.e. if the fully-qualified class name
is "zap.Tension",  then the file must be stored under "zap/Tension.class".
  
<p><b>Commands, CommandEncoders, and GameComponents</b> </p>
   
<p>What is the proper event handler for the button? We can increment the tension
index in our own instance of the Tension class, but how do we communicate 
 that change to our opponent? The opponent may be connected live via the server
or may be reading a logfile that we've written. Both cases are handled in
the same way and at the same time. </p>
   
<p>For any action that can be communicated between two players, we must make
 a corresponding Command class. Command subclasses my implement the executeCommand()
 method, which does whatever you want the command to perform, and the myUndoCommand()
 method, which should return a new Command object that undoes whatever the
 first Command did. It is valid to return null for myUndoCommand(). </p>
   
<p>For the Tension class, we define an inner Command class that adds an increment
 to the Tension index </p>
   
<pre>&nbsp;&nbsp;&nbsp; public static class Incr extends Command {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private Tension target;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private int change;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Incr(Tension target, int change) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.target = target;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.change = change;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected void executeCommand() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target.addToIndex(change);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected Command myUndoCommand() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Incr(target,-change);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public int getChange() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return change;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }</pre>
   Once the Command class is defined, we can provide the event handler for 
the increment button:   
<pre>&nbsp;&nbsp;&nbsp; private void incrementButtonPressed() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GameModule mod = GameModule.getGameModule();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int change = newIncrement();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Command c = new<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chatter.DisplayText(mod.getChatter(),"Tension changes by "+change);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c.append(new Incr(this,change));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c.execute();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod.sendAndLog(c);<br>&nbsp;&nbsp;&nbsp; }</pre>
   Here, we have used an existing Command, Chatter.DisplayText(), which displays 
 a message in the Chat window. We use the append() method to combine both 
commands into a single compound Command. The sendAndLog() method sends the 
Command over the server (if currently connected) and writes it to the current 
logfile (if one is being written).   
<p>The "total" button doesn't actually change the state of the game. It just
 displays information locally, so its event handler doesn't need to involve
 any Commands: </p>
   
<pre>&nbsp;&nbsp;&nbsp; private void totalButtonPressed() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GameModule.getGameModule().getChatter().show("Tension index is "+index);<br>&nbsp;&nbsp;&nbsp; }</pre>
   Once we have created a Command, how does VASSAL on the opponent's machine 
 know how to recognize it? A CommandEncoder turns Commands into strings and
 vice versa. For a Command to be translatable to and from plain text, it
must  be recognized by a CommandEncoder. We now add methods to the Tension
class  to implement the CommandEncoder interface.   
<pre>&nbsp;&nbsp;&nbsp; public static final String COMMAND_PREFIX = "TENSION:";<br>&nbsp;&nbsp;&nbsp; public String encode(Command c) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (c instanceof Incr) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return COMMAND_PREFIX+((Incr)c).getChange();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public Command decode(String s) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s.startsWith(COMMAND_PREFIX)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Incr(this,Integer.parseInt(s.substring(COMMAND_PREFIX.length())));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }</pre>
   Your encoded command should have a unique identifying string at the beginning, 
 but otherwise you are free to encode the necessary data to recreate your 
Command any way to choose.   
<p>In the addTo() method, we need to tell VASSAL to use our class to encode 
 commands: </p>
   
<pre>GameModule.getGameModule().addCommandEncoder(this);</pre>
   Finally, in order to include the Tension index along with other information 
 when saving a game, we must implement the GameComponent interface. The first
 method is invoked when a game is opened or closed   
<pre>&nbsp;&nbsp;&nbsp; public void setup(boolean gameStarting) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!gameStarting) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }</pre>
   The second method returns a Command that restores this class to its current 
 state   
<pre>&nbsp;&nbsp;&nbsp; public Command getRestoreCommand() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Incr(this,index);<br>&nbsp;&nbsp;&nbsp; }</pre>
   The full code for the Tension class is included in the "module data" directory 
 within the tutorial directory.   
<p>This example should give you an idea of how you can write classes that 
 can do just about anything you like and use them in a VASSAL module. Most 
 classes will probably be added either to the GameModule or to a Map, but 
because of the extreme flexibility of the framework, just about anything is
possible. Go crazy! <br>
  &nbsp; </p>
   
<hr> <a name="counters"> </a>  
<center><a name="counters"><b><font size="+2">Creating custom counters for
 VASSAL</font></b></a></center>
      
<p> <a name="counters">	Nifty though it is, sometimes VASSAL's game piece
 designer dialog just doesn't do everything you want.  In that case, you
have  the option to write your own Java code that creates your own customized 
game piece class.  In this tutorial, we'll create a game piece that can be 
magnified by an arbitrary factor. </a></p>
   
<p> <a name="counters">      In almost all cases, the customization can be
 done by overriding one class, Decorator.  Decorator is an abstract class
that wraps around a GamePiece and adds functionality to it.  In the game
piece designer dialog, each "trait" is actually an instance of the Decorator
 class.  We will create an instance of Decorator called </a><a
 href="ZapWarsData/src/zap/Magnifier.java"><tt>Magnifier.java</tt></a>. 
</p>
   
<p> 	Along with implementing a Decorator class, we must create a CommandEncoder
 that will recognize it. (See "Commands, CommandEncoders, and GameComponents"
 in the module-coding tutorial.) By default, VASSAL only recognizes counters
 in the VASSAL package.  We will create a class <a
 href="ZapWarsData/src/zap/MyCounterFactory.java"><tt>MyCounterFactory.java</tt></a>, 
 that recognized our The class that builds counters is the BasicCommandEncoder
 class.  Creating our own implementation is easy: </p>
   
<pre> public class MyCounterFactory extends BasicCommandEncoder<br>{<br>    public Decorator createDecorator(String type, GamePiece inner) {<br>	Decorator piece = null;<br>	if (type.startsWith(Magnifier.ID)) {<br>	    piece = new Magnifier(type,inner);<br>	}<br>	else {<br>	    piece = super.createDecorator(type,inner);<br>	}<br>	return piece;<br>    }<br>}<br></pre>
   	When we add this component to the module (see below), VASSAL will recognize
 our new counter whenever it appears in a savefile, logfile, or online. The important part is the overridden <tt>createDecorator()</tt> method.  The rest are empty implementations of the <tt>Configurable</tt> interface.  
  
<p> 	The key attributes of a Decorator are its "type" and its "state."  The
 "type" is a string that must begin with a unique character sequence (in
order  to be recognized by the counter factory). The sequence for the Magnifier
class is given by Magnifier.ID.  The rest of the "type" contains all information
 about the piece that is fixed at module-design time.  In our case, this
is  the minimum and maximum magnification factor.   </p>
   
<pre>    public String myGetType() {<br>	return ID+minMag+";"+maxMag;<br>    }<br></pre>
       We also have a corresponding mySetType() method:   
<pre>    public void mySetType(String type) {<br>	type = type.substring(ID.length);<br>	int i = type.indexOf(";");<br>	try {<br>	    minMag = Double.valueOf(type.substring(0,i)).doubleValue();<br>	}<br>	catch (NumberFormatException ex) {<br>	    ex.printStackTrace();<br>	}<br>	try {<br>	    maxMag = Double.valueOf(type.substring(i+1)).doubleValue();<br>	}<br>	catch (NumberFormatException ex) {<br>	    ex.printStackTrace();<br>	}<br>    }<br></pre>
     
<p>     The mySetType() method always expects an input argument which is the
same as the value returned by myGetType(). </p>
   
<p>     The "state" of a piece is information that changes in the course
of a game.  In the case of the Magnifier class, the state information is
the magnification factor: </p>
   
<pre>    public String myGetState() {<br>	return ""+mag;<br>    }<br><br>    public void mySetState(String s) {<br>	try {<br>	    mag = Double.valueOf(s).doubleValue();<br>	}<br>	catch (NumberFormatException ex) {<br>	    ex.printStackTrace();<br>	    mag = 1.0;<br>	}<br>    }<br></pre>
     
<p>     The state information changes when the user enters a keyboard command
 or selects a popup menu item after right-clicking on the counter.  We specify
 what keyboard commands affect the counter with the myKeyEvent method.  If
 the keystroke in the argument matches CTRL-M (the instance variable 'magnifyCommand'),
 we set the magnification factor.  We also must return a Command object that 
 reproduces the change for our opponent: </p>
   
<pre>	    GamePiece target = Decorator.getOutermost(this);<br>	    String oldState = target.getState();<br>	    // Prompt user for magnification factor<br>	    return new ChangePiece(target.getId(),oldState,target.getState());<br></pre>
     
<p>     The Command returned is a ChangePiece command.  It's important to 
 note that the target of the command is not necessarily the Magnifier instance.
  Remember that a Decorator is a wrapper around another game piece (specified
 by getInner()).  Each one modifies the game piece that it wraps around.
 The actual, complete, game piece is the outermost Decorator instance, which
is obtainable from the Decorator.getOutermost() method. </p>
   
<p>       We now specify the corresponding command in the popup menu by implementing
 the myGetKeyCommands() method: </p>
   
<pre>     commands = new KeyCommand[]{new KeyCommand("Magnify",magnifyCommand,this)};<br></pre>
     
<p>      Now that we are able set the magnification factor, we can use it
 when we draw the counter by implementing the draw() method.   </p>
   
<pre>public void draw(Graphics g, int x, int y, Component obs, double zoom) {<br>   getInner().draw(g,x,y,obs,zoom*mag);<br>}    <br></pre>
      
<p>We must also implement the boundingBox() and selectionBounds() methods
 to tell VASSAL how large the counter is. </p>
   
<p>        At this point, the piece could be used by hand-editing the buildFile,
 but implementing the EditablePiece interface makes the counter much easier
 to include into a module.  Only a minimal implementation is necessary. </p>
   
<pre>    public VASSAL.build.module.documentation.HelpFile getHelpFile() {<br>	return null;<br>    }<br>    public PieceEditor getEditor() {<br>	return new SimplePieceEditor(this);<br>    }<br></pre>
   The SimplePieceEditor class prompts the user to supply the "type" and
"state"  strings when adding this trait to a piece in the module editor.
   
<p> 	To configure our module to use this piece:  </p>
   
<ol>
    <li>Use a zip program to add the MyCounterFactory.class and Magnifier.class
 files to the module.  (Remember that the module file is an ordinary zip
file,  but may have to be renamed to have a .zip extension).  Because the
classes  are declared to be in the 'zap' package, remember to place them
in a "zap"  folder in the zipfile.</li>
    <li>In the Configuration window of the module editor, right-click on
the  Module folder and select "Add Imported Class".  Enter "zap.MyCounterFactory"</li>
    <li>In the Configuration window, select a piece that you wish to have 
to the Magnifyable trait and bring up its properties.</li>
    <li>Hit the "Import" button and enter the class name, "zap.Magnifier".
  The Magnifyable trait will appear in the list of available traits.  Select
 it and hit the "Add" button.</li>
    <li>Do the same for any other pieces that need the Magnifyable trait, 
or clone the original piece and make modifications to the clone.    </li>
   
</ol>
  <br>
  <br>
  <br>
 <br>
</body>
</html>
