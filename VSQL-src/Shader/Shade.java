/*
 * $Id$
 * 
 * Copyright (c) 2005 by Rodney Kinney, Brent Easton
 * 
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Library General Public License (LGPL) as published by
 * the Free Software Foundation.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Library General Public License
 * along with this library; if not, copies are available at
 * http://www.opensource.org.
 */

package Shader;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Rectangle;
import java.awt.TexturePaint;
import java.awt.geom.Area;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

import VASSAL.build.AbstractConfigurable;
import VASSAL.build.AutoConfigurable;
import VASSAL.build.Buildable;
import VASSAL.build.GameModule;
import VASSAL.build.module.Map;
import VASSAL.build.module.documentation.HelpFile;
import VASSAL.configure.ColorConfigurer;
import VASSAL.configure.StringEnum;
import VASSAL.configure.VisibilityCondition;
import VASSAL.counters.GamePiece;
import VASSAL.counters.Stack;

/**
 * 
 * @author Brent Easton
 *
 * Display the Shade generated by Units generating this Shade type.
 * Pre-calculate and cache as much as possible.
 */
public class Shade extends AbstractConfigurable {

  public static final String NAME = "name";
  public static final String TYPE = "type";
  public static final String PATTERN = "pattern";
  public static final String COLOR = "color";
  public static final String IMAGE = "image";
  public static final String OPACITY = "opacity";
  public static final String BORDER = "border";
  public static final String BORDER_COLOR = "borderColor";
  public static final String BORDER_WIDTH = "borderWidth";

  public static final String RANGE_TEXT = "rangeType";
  public static final String RANGE = "range";

  public static final String BG_TYPE = "Background";
  public static final String FG_TYPE = "Foreground";

  public static final String TYPE_25_PERCENT = "25%";
  public static final String TYPE_50_PERCENT = "50%"; 
  public static final String TYPE_75_PERCENT = "75%"; 
  public static final String TYPE_SOLID = "100% (Solid)"; 
  public static final String TYPE_IMAGE = "Custom Image";

  protected String defaultRangeText = "";
  protected int defaultRange = 3;
//  protected int builtRange = 3;
  protected String imageName = "";
  protected Color color = Color.BLACK;
  protected String type = FG_TYPE;
  protected String pattern = TYPE_25_PERCENT;
  protected int opacity = 100;
  protected boolean border = false;
  protected Color borderColor = Color.BLACK;
  protected int borderWidth = 1;

  //protected ShadeableMap map;
  protected Area shape;
  protected BufferedImage shadePattern = null;
  protected Rectangle patternRect = new Rectangle();

  protected Area myShape = null;
  protected BufferedImage myShapeImage = null;
  protected Graphics2D myShapeGraphics = null;
  protected Map lastMap;
  protected Rectangle lastRectangle;
  protected boolean dirty = true;
  
  protected TexturePaint texture = null;
  protected AlphaComposite composite = null;
  protected BasicStroke stroke = null;
  protected double lastZoom = 0;
  
  public Shade() {
    super();
  }

  public void draw(Graphics g, Map map, Rectangle visibleRect) {

    Graphics2D g2 = (Graphics2D) g;
    g2.setComposite(getComposite());
    g2.setColor(getColor());
    g2.setPaint(getTexture());
    g2.fill(getShadeShape(map, visibleRect));
    if (border) {
      g2.setStroke(getStroke(map.getZoom()));
      g2.setColor(getBorderColor());
      g2.draw(getShadeShape(map, visibleRect));
    }

  }
  
  /**
   * Get/Build the AlphaComposite used to draw the semi-transparent shade/
   */
  protected AlphaComposite getComposite() {
    if (composite == null) {
      buildComposite();
    }
    return composite;
  }

  protected void buildComposite() {
    composite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, opacity / 100.0f);
  }
  
  public void setDirty(boolean b) {
    dirty = b;
  }

  /**
   * Get/Build the shape of the shade.
   */
  protected Area getShadeShape(Map map, Rectangle visibleRect) {
    
    if (myShape == null || dirty || map != lastMap || !visibleRect.equals(lastRectangle)) {      
      buildShadeShape(map, visibleRect);
      lastMap = map;
      lastRectangle = visibleRect;
      dirty = false;
    }
    return myShape;
  }
  
  public void buildShadeShape(Map map, Rectangle visibleRect) {
    
    if (type.equals(FG_TYPE)) {
      myShape = new Area();
    }
    else {
      myShape = new Area(visibleRect);
    }
    
    GamePiece pieces[] = map.getPieces();
    for (int i = 0; i < pieces.length; i++) {
      checkPiece(myShape, pieces[i], map);
    }
    
  }

  protected void checkPiece(Area area, GamePiece piece, Map map) {
    if (piece instanceof Stack) {
      Stack s = (Stack) piece;
      for (int i = 0; i < s.getPieceCount(); i++) {
        checkPiece(area, s.getPieceAt(i), map);
      }
    }
    else {
      Area shape = (Area) piece.getProperty(name + Shading.SHAPE);
      if (shape != null) {
        if (type.equals(FG_TYPE)) {
          area.add(shape);
        }
        else {
          area.subtract(shape);
        }
      }
    }
  }

  /**
   * Get/Build the repeating rectangle used to generate the shade.
   */
  protected BufferedImage getShadePattern() {
    if (shadePattern == null) {
      buildShadePattern();
    }
    return shadePattern;
  }
  
  protected Rectangle getPatternRect() {
    return patternRect;
  }
  
  protected void buildShadePattern() {
    
    if (pattern.equals(TYPE_IMAGE)) {
      try {
        shadePattern = (BufferedImage) GameModule.getGameModule().getDataArchive().getCachedImage(imageName);
      }
      catch (IOException ex) {
      }
    }
    else {
      shadePattern = new BufferedImage(2, 2, BufferedImage.TYPE_4BYTE_ABGR);
      Graphics2D g2 = shadePattern.createGraphics();
      g2.setColor(color);
      if (pattern.equals(TYPE_25_PERCENT)) {
        g2.drawLine(0, 0, 0, 0);
      }
      else if (pattern.equals(TYPE_50_PERCENT)) {
        g2.drawLine(0, 0, 0, 0);
        g2.drawLine(1, 1, 1, 1);
      }
      else if (pattern.equals(TYPE_75_PERCENT)) {
        g2.drawLine(0, 0, 1, 0);
        g2.drawLine(1, 1, 1, 1);
      }
      else if (pattern.equals(TYPE_SOLID)) {
        g2.drawLine(0, 0, 1, 0);
        g2.drawLine(0, 1, 1, 1);
      }
    }

    patternRect = new Rectangle(0, 0, shadePattern.getWidth(), shadePattern.getHeight());
  }
  
  protected BasicStroke getStroke(double zoom) {
    
    if (stroke == null || zoom != lastZoom) {
      buildStroke(zoom);
      lastZoom = zoom;
    }

    return stroke;
  }
  
  protected void buildStroke(double zoom) {
    float width = (float) (borderWidth * zoom);
    if (width < 1.0f) {
      width = 1.0f;
    }
    stroke = new BasicStroke(width, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND);
  }
  
  public Color getBorderColor() {
    return borderColor;
  }
  
  /**
   * Get/Build the textured paint used to fill in the Shade
   */
  protected TexturePaint getTexture() {
    if (texture == null) {
      buildTexture();
    }
    return texture;
  }
  
  protected void buildTexture() {
    texture = new TexturePaint(getShadePattern(), getPatternRect());
  }
  
  public Color getColor() {
    return color;
  }
  
  protected int getDefaultRange() {
    return defaultRange;
  }

  public String[] getAttributeDescriptions() {
    return new String[] { "Name:  ", "Type:  ", "Shade Pattern:  ", "Color:  ", "Image:  ",
        "Border?  ", "Border Color:  ", "Border Width:  ",
        "Opacity(%):  ", "Default Range Text:  ", "Default Range:  " };
  }

  public Class[] getAttributeTypes() {
    return new Class[] { String.class, TypePrompt.class, PatternPrompt.class, Color.class, Image.class,
        Boolean.class, Color.class, Integer.class,
        Integer.class, String.class, Integer.class };
  }

  public static class TypePrompt extends StringEnum {
    public String[] getValidValues(AutoConfigurable target) {
      return new String[] { FG_TYPE, BG_TYPE };
    }
  }
  
  public static class PatternPrompt extends StringEnum {
    public String[] getValidValues(AutoConfigurable target) {
      return new String[] { TYPE_25_PERCENT, TYPE_50_PERCENT, TYPE_75_PERCENT, TYPE_SOLID, TYPE_IMAGE };
    }
  }


  public String[] getAttributeNames() {
    return new String[] { NAME, TYPE, PATTERN, COLOR, IMAGE, BORDER, BORDER_COLOR, BORDER_WIDTH, OPACITY, RANGE_TEXT, RANGE };
  }

  public void setAttribute(String key, Object value) {
    if (NAME.equals(key)) {
      setConfigureName((String) value);
    }
    else if (TYPE.equals(key)) {
      type = (String) value;
    }
    else if (PATTERN.equals(key)) {
      pattern = (String) value;
      buildShadePattern();
      buildTexture();
    }
    else if (COLOR.equals(key)) {
      if (value instanceof String) {
        value = ColorConfigurer.stringToColor((String) value);
      }
      color = (Color) value;
      buildShadePattern();
      buildTexture();
    }
    else if (IMAGE.equals(key)) {
      if (value instanceof File) {
        value = ((File) value).getName();
      }
      imageName = (String) value;
      buildTexture();
    }
    else if (BORDER.equals(key)) {
      if (value instanceof String) {
        value = new Boolean((String) value);
      }
      border = ((Boolean) value).booleanValue();
    }
    else if (BORDER_COLOR.equals(key)) {
      if (value instanceof String) {
        value = ColorConfigurer.stringToColor((String) value);
      }
      borderColor = (Color) value;
    }
    else if (BORDER_WIDTH.equals(key)) {
      if (value instanceof String) {
        value = new Integer((String) value);
      }
      borderWidth = ((Integer) value).intValue();
      if (borderWidth < 0) {
        borderWidth = 0;
      }
      stroke = null;
    }
    else if (OPACITY.equals(key)) {
      if (value instanceof String) {
        value = new Integer((String) value);
      }
      opacity = ((Integer) value).intValue();
      if (opacity < 0 || opacity > 100) {
        opacity = 100;
      }
      buildComposite();
    }
    else if (RANGE_TEXT.equals(key)) {
      defaultRangeText = (String) value;
    }
    else if (RANGE.equals(key)) {
      if (value instanceof String) {
        value = new Integer((String) value);
      }
      defaultRange = ((Integer) value).intValue();
    }
  }

  public String getAttributeValueString(String key) {
    if (NAME.equals(key)) {
      return getConfigureName();
    }
    else if (TYPE.equals(key)) {
      return type + "";
    }
    else if (PATTERN.equals(key)) {
      return pattern + "";
    }
    else if (COLOR.equals(key)) {
      return ColorConfigurer.colorToString(color);
    }
    else if (IMAGE.equals(key)) {
      return imageName + "";
    }
    else if (BORDER.equals(key)) {
      return String.valueOf(border);
    }
    else if (BORDER_COLOR.equals(key)) {
      return ColorConfigurer.colorToString(borderColor);
    }
    else if (BORDER_WIDTH.equals(key)) {
      return borderWidth + "";
    }
    else if (OPACITY.equals(key)) {
      return opacity + "";
    }
    else if (RANGE_TEXT.equals(key)) {
      return defaultRangeText;
    }
    else if (RANGE.equals(key)) {
      return defaultRange + "";
    }
    else {
      return null;
    }
  }

  public VisibilityCondition getAttributeVisibility(String name) {

   if (COLOR.equals(name)) {
      return new VisibilityCondition() {
        public boolean shouldBeVisible() {
          return !pattern.equals(TYPE_IMAGE);
        }
      };
    }
   else if (IMAGE.equals(name)) {
      return new VisibilityCondition() {
        public boolean shouldBeVisible() {
          return pattern.equals(TYPE_IMAGE);
        }
      };
    }
    else {
      return super.getAttributeVisibility(name);
    }
  }

  public static String getConfigureTypeName() {
    return "Shade";
  }

  public void removeFrom(Buildable parent) {
    ((MapShader) parent).removeShade(this);
  }

  public HelpFile getHelpFile() {
    return null;
  }

  public Class[] getAllowableConfigureComponents() {
    return new Class[0];
  }

  public void addTo(Buildable parent) {
    ((MapShader) parent).addShade(this);
  }

}